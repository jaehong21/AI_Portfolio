---
description: >-
  CNN(합성곱 신경망)은 DNN(Deep Neural Network)이 이미지나 영상과 같은 데이터를 처리함에 있을 때의 문제점을 보완한
  방법이다.
---

# Basic Information

## DNN \(Deep Neural Network\)

DNN은 **입력층\(input layer**\), **출력층\(output layer\)**, 그리고 그 사이에 여러개의 **은닉층\(hidden layer\)**로 이루어져 있는 **ANN\(Artificial Neural Network, 인공신경망\)** 중 하나다. 인간의 뉴런이 연결되어 있는 형태로부터 착안되었다.

![ANN Figure](../.gitbook/assets/image%20%2858%29.png)

우리의 뇌는 일정 자극을 받은 , 역치\(threshold\) 혹은 임계점을 넘기면, 활동전위\(action potential\)와 같은 출력값을 내보낸다. ANN 또한, input을 받고, Hidden Layer에서 임계값을 넘게 되면, output을 출력하는 방식이다.

그렇다면, DNN은 무엇인가? ANN 이후에 모델 내의 은닉층의 개수를 늘리는 것이 효과적인 학습으로 이어질 수 있음을 알게 되고, 이를 심층신경망 혹은 DNN으로 부르게 된 것이다. 각 층에 존재하는 한 단위의 인공뉴런을 **노드\(node\)**라고 한다. 그리고, 다른 신경세포로 이동하기 전에 마치 화학적 반응과 함께 시냅스를 거치는 것처럼 에서는 수학적인 연산을 거친다. 그리고 각 층마다 존재하는 **가중치\(weight\)**를 행렬곱하고 **편향\(bias\)**를 더해준다. 그리고, 이 행렬곱의 결과가 바로 활성화 함수\(activation function\)이다. 활성화 함수가 역치\(threshold\)를 넘었는가 넘지 않았는가를 결정할 수 있게 해준다. 이 활성화 함수의 결과값은 여러 은닉층을 거쳐서, 가중치 곱과 활성화 감수를 듭해서 거치게 되고, 마지막 output layer에서 최종적인 결과값을 만들어낸다. 그 이후에 결괏값과 실제 값과의 오차를 토대로 경사하강법을 이용하여 가중치를 계속하여 수정하는 방식으로 신경망을 학습시킨다. 이를 **역전파\(Backpropagation\)** 알고리즘이라고 한다. \(실제로는 여러개의 층을 가지고 있는 신경망으 역전파 구현은 복잡하고 어렵다고 한다. 하지만, 우리가 사용하는 파이토치는 역전파 기법을 기본적으로 제공한다\)

DNN은 기본적으로 1차원 형태의 데이터를 사용한다.

| sepal length\(cm\) | sepal width\(cm\) | petal length\(cm\) | petal width\(cm\) | target |
| :---: | :---: | :---: | :---: | :---: |
| 5.1 | 3.5 | 1.4 | 0.2 | setosa |

위 표와 같은 Iris\(붓꽃\) 데이터셋을 예시로 들면, input은 꽃받침이나 꽃잎의 길이를 입력하면, output으로 꽃의 종류로 설정하여, 학습을 진행하는 것이다. Iris 데이터를 1차원 형태의 데이터라고 하는 하나의 row로 이루어지기 때문이다. 

## CNN \(Convolution Neural Network\)의 사용

하지만, 밑과 같은 이미지를 한 줄로 데이터화 해서 표현할 수 있는가? 일단 저 사진들을 아주 작은 단위로 쪼개서 데이터화 시킨다고 하자. 이미지 같은 경우에는 한 점\(pixel\)을 기준으로 주위 점과 모여서 객체를 형성한다. 그런데, 만약에 사진을 모두 쪼개서 1차원 형태의 데이터로 나열한다면 이러한 픽셀 간의 연관관계가 전부 삭제된다.

![Left\) &#xC22B;&#xC790; 2, Right\) &#xC0AC;&#xC9C4; &#xD53D;&#xC140;&#xD654;](../.gitbook/assets/image%20%2831%29.png)

회색 비중이 많은 픽셀을 1, 흰색 비중이 많은 픽셀을 0이라고 가정한다. CNN은 이미지에서의 한 픽셀과 주변 다른 픽셀과의 연관관계를 유지시키면서 모델을 학습시키는 것을 목표로 한다. 이는 연관성을 나타내는 새로운 이미지를 여러 장 생성시키는 것부터 시작한다. 

### Convolution Layer

![](../.gitbook/assets/image%20%2818%29.png)

​일단, 3X3 크기로 데이터를 추출하자. 그리고, 랜덤값을 가지는 3X3 데이터도 제작한다. 이 랜덤값을 가지는 데이터는 '필터'라고 부른다. 그리고, 필터의 종류마다 서로 다른 값이 출력되는 것을 확인할 수 있었다. 그렇게, 필터를 이용하면 9개의 픽셀로부터 한 개의 값을 생성할 수 있다. 그렇게, 빨간색 칸을 한 칸씩 옮겨간다면, 12X12 이미지에서 필터로부터 얻은 값으로 형성된 10X10 이미지를 생성하게 된다. 만약, 위 사진과 같이 필터가 3개라면, 새로운 세 개의 10X10 이미지가 만들어질 것이다. 이 과정을 Convolution이라고 하며, CNN의 핵심 부분 중 하나이다. 

더 나아가기 전에, **Filter\(=kernel\)**에 대하여 조금 더 자세하게 알아보자. 필터는 그 데이터에 어떤 특징이 있는지 없는지 검출해주는 함수이다. 

![](../.gitbook/assets/image%20%2821%29.png)

필터 또한 행렬로 정의된다. 이 필터를 이미지로 구현하면, 위와 같은 곡선이 된다. 

![](../.gitbook/assets/image%20%2837%29.png)

위 Figure 중 윗줄에서 잘라낸 곡선 이미지에 Filter를 적용해보자. 그럼 필터 결괏값이 매우 크게 나온다. 하지만, 아래와 같이 곡선이 없는 부분을 Filter에 적용하면 결과값이 0에 수렴한다. 즉, 필터는 이 필터와 유사한 특징을 가진 데이터로부터는 큰 값을 반환함으로써 데이터가 그 특징을 가지고 있는지 없는 판별할 수 있게 해준다. 하지만, 실제 CNN에서는 입력값이 한 가지가 아닌 여러가지 특징이 있기 때문에, 다중 필터를 적용한다.  
Convolutional Layer에서 **가중치\(weight\)**는 커널 행렬의 원소이다. 그리고, **편향\(bias\)**은 필터를 적용한 이후에 더해집니다. 편향은 오직 하나의 값이며, 행렬의 모든 원소에 더해지게 됩니다.

12X12 이미지에서 10X10 이미지로 크기가 변환되는 것은 괜찮은 것일까? 이를 방지하고자 **padding**이라는 개념이 존재한다. 바로 빈 공간에 0이라는 값을 부여하며, 원래의 이미지와 동일한 크기를 유지시키는 것이다. 

### Pooling

Convolution 과정에서는 문제점이 하나 있다. 과정을 반복할수록 계속해서 새로운 이미지를 생성한다는 것이다.  그래서, 고안한 방법이 Pooling\(sub sampling\)이다. Pooling은 간단히 말하자면, 특징을 뽑아내는 과정이라고 할 수 있다. 이를 이용하면, 필요하지 않는 자료까지 분석하는 불필요한 시간 소모를 생략하며, 쓸데없는 parameter의 수를 줄임으로써 훈련데이터만 쌓이는 과적합\(overfitting\)을 예방할 수 있다. 

Pooling에도 종류가 있다.

1. Max Pooling: 정해진 Filter 크기 안에서 가장 큰 값만 추출한다
2. Average Pooling: 정해진 Filter  값들의 평균을 추출한다

보통 Max Pooling을 이용한다. Convolution의 결과인 Feature maps에서 Filter마다 특징을 찾는 것이 Pooling의 목적이다. Feature maps에서 큰 반환값 그 Filter가 찾아내고자 하는 특징에 가깝다는 것을 뜻하기 때문이다.

![](../.gitbook/assets/image%20%2860%29.png)

+\) stride는 한 번에 이동하는 칸 수이다. 만약 4X4에서 2X2 Filter로 stride 2로 Max Pooling 한다면, 위 Figure과 같은 size의 데이터를 얻을 것이다.

따라서, Pooling은 Padding 없이 Filter만을 이용해서 1개의 이미지에서 1개의 출력을 만들면서 크기를 줄이는 방법을 말한다.

### Flatten

![CNN &#xC804;&#xCCB4; &#xACFC;&#xC815;](../.gitbook/assets/image%20%2834%29.png)

Convolution과 Pooling을 반복하면, 이미지의 숫자가 많아지는 동시에 크기는 줄어든다. 이러한 과정을 거듭하면, 본래 2차원의 이미지가 1차원의 하나의 특이점 혹은 데이터처럼 변한다. 이를 Flattened라고 말하는 것이다. 그러면, 2차원의 데이터가 1차원의 row 형태로 데이터를 나열할 수 있는 구조가 된다. 이제부터는 그러면 다시 DNN을 사용하여 Output을 출력하면 되는 것이다.

Flatten Layer는 CNN의 데이터 타입을 **Full Contacted Layer \(FC\)**의 형태로 변경해주는 것이다. 이전 레이어의 모든 노드가 다음 레이어의 모든 노드에 연결된 레이를 FC Layer\(Dense Layer\)라고 한다. FC Layer만으로 이루어진 인공 신경망은 사실 1차원 배열 형태로 한정된다. 결국 위에서 언급했듯이, CNN은 이미지의 공간 정보를 유지한 채로 1차원인 FC Layer로 평면화시켜주는 것이다. Flatten Layer는 parameter가 따로 존재하지 않고, 오직 입력데이터를 1차원으로 Shape 변경만 수행한다. 이는 이후 예제에서 살펴볼 수 있을 것이다.

### Channel

이미지 처리 중에서 쓰이는 용어 중에서 채널\(Channel\)이 있다. 위에서는 설명을 위해 2차원 텐서로 표현했지만, 실제로는 높이, 너비, 채널로 이루어진 3차원 텐서이다. 너비와 높이는 이미지의 가로, 세로 픽셀 수를 나타내며, 채널은 이미지의 색 성분을 나타낸다. 각 픽셀은 0~255 사이의 값을 가지며, 흑백 이미지는 1개의 채널 수를 갖는다. 밑 손글씨 데이터는 흑백 이미지이므로 \(28 X 28 X 1\)의 크기를 가진 3차원 텐서다. 

![](../.gitbook/assets/image%20%2844%29.png)

위 오른쪽 사진과 같이 통상적인 컬러 이미지는 Red, Green, Blue가 혼합된 3개의 채널로 이루어진 것이다. \(채널은 때로 깊이, depth라고도 한다\)

입력 데이터의 채널 수와 커널의 채널 수는 똑같아야 한다. 서로 채널 수가 같으므로 합성곱 연산을 채널마다 수행해준다. 그리고, 나중에 이를 모두 종합하여 최종적인 특성 맵 하나를 얻는다. 그리고, 필터의 크기는 각 채널마다 모두 같아야 한다. ~~그리고, 밑의 연산에서 사용되는 필터는 3개의 다른 필터가 아닌 3개의 채널을 가진 한 개의 커널이다.~~  
합성곱 연산의 결과로 얻은 Feature map의 채널의 차원은 위에서 언급한 RGB 채널 등과 같은 컬러의 의미를 담고 있지는 않다.   
~~~~

![](../.gitbook/assets/image%20%287%29.png)

![](../.gitbook/assets/image%20%2853%29.png)

### Epoch, Batch\_size, iteration

CNN에서는 **epoch**와 **batch**라는 개념을 알 필요가 있다. one epoch는 인공신경망에서 전체 데이터셋에서 foward pass/backward pass이 한 번 완료됐음을 이야기한다. 쉽게 말하자면, 한 번의 epoch는 전체 데이터셋에 대해 한 번의 학습 과정이 완료됨을 뜻한다. 그런데, 메모리의 한계와 속도 저하 때문에 한 번의 epoch에서 모든 데이터를 한꺼번에 집어넣고 작업을 처리할 수는 없다고 한다. 그리하여, one epoch에서도 데이터를 나누어서 처리하게 된다. 이때, 나누는 횟수를 **iteration,** 그리고 각 iteration마다 받게 되는 데이터의 크기를 batch size라고 부르게 되는 것이다.   
예\) 총 2000개의 데이터가 있다. epochs = 20, batch\_size = 500이라면, 각 데이터의 size가 500인 4번의 iteration이 이루어진다. 그리고, 4번의 iteration과 20 epochs로 총 80번의 학습이 진행된다.

![](../.gitbook/assets/image%20%286%29.png)

